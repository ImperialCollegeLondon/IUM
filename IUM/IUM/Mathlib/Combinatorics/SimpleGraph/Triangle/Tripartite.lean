/-
Copyright (c) 2023 Ya√´l Dillies, Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Ya√´l Dillies, Bhavik Mehta
-/
import Mathlib.Combinatorics.SimpleGraph.Triangle.Basic

#align_import mathlib.combinatorics.simple_graph.triangle.tripartite

/-!
# Construct a tripartite graph from its triangles

This file contains the construction of a simple graph on `Œ± ‚äï Œ≤ ‚äï Œ≥` from a list of triangles
`(a, b, c)` (with `a` in the first summand, `b` in the second, `c` in the third).

We call
* `t : finset (Œ± √ó Œ≤ √ó Œ≥)` the set of *triangle indices* (its elements are not triangles within the
  graph but instead index them).
* *explicit* a triangle of the constructed graph coming from a triangle index.
* *accidental* a triangle of the constructed graph not coming from a triangle.

The two important properties of this construction are:
* `simple_graph.tripartite_from_triangles.explicit_disjoint`: Whether the explicit triangles are
  edge-disjoint.
* `simple_graph.tripartite_from_triangles.no_accidental`: Whether all triangles are explicit.

This construction shows up unrelatingly twice in the theory of Roth numbers:
* The lower bound of the Ruzsa-Szemer√©di problem: From a Salem-Spencer set `s` on a commutative ring
  `Œ±` (in which `2` is invertible), we build a locally linear graph on `Œ± ‚äï Œ± ‚äï Œ±`. The triangle
  indices are `(x, x + a, x + 2 * a)` for `x` any element and `a ‚àà s`. The explicit triangles are
  edge-disjoint and accidental triangles correspond to arithmetic progressions of length 3 in `s`.
* The proof of the corners theorem from the triangle removal lemma. For a subset `s` of the `n √ó n`
  grid, we construct a tripartite graph whose vertices are the horizontal, vertical and diagonal
  lines in the grid. The explicit triangles are `(h, v, d)` where `h`, `v`, `d` are horizontal,
  vertical, diagonal lines that intersect in an element of `s`. The explicit triangles are
  edge-disjoint. Accidental triangles correspond to non-trivial corners.

# Main declarations

* `simple_graph.tripartite_from_triangles.graph`: The tripartite simple graph generated by the given
  triangle indices.
* `simple_graph.tripartite_from_triangles.explicit_disjoint`: Predicate on triangle indices for the
  constructed graph to have edge-disjoint explicit triangles.
* `simple_graph.tripartite_from_triangles.no_accidental`: Predicate on triangle indices for there to
  be no accidental triangles.
* `simple_graph.tripartite_from_triangles.locally_linear`: If both predicates hold, the constructed
  graph is locally linear.
-/


open Finset Function Sum3

variable {Œ± Œ≤ Œ≥ ùïú : Type _} [LinearOrderedField ùïú] {t : Finset (Œ± √ó Œ≤ √ó Œ≥)} {a a' : Œ±} {b b' : Œ≤}
  {c c' : Œ≥} {x : Œ± √ó Œ≤ √ó Œ≥} {Œµ : ùïú}

namespace SimpleGraph

namespace TripartiteFromTriangles

/-- The underlying relation of the tripartite-from-triangles graph. Two vertices are related iff
there exists a triangle index containing them both. -/
@[mk_iff]
inductive Rel (t : Finset (Œ± √ó Œ≤ √ó Œ≥)) : Sum Œ± (Sum Œ≤ Œ≥) ‚Üí Sum Œ± (Sum Œ≤ Œ≥) ‚Üí Prop
  | in‚ÇÄ‚ÇÅ ‚¶Éa b c‚¶Ñ : (a, b, c) ‚àà t ‚Üí Rel (in‚ÇÄ a) (in‚ÇÅ b)
  | in‚ÇÅ‚ÇÄ ‚¶Éa b c‚¶Ñ : (a, b, c) ‚àà t ‚Üí Rel (in‚ÇÅ b) (in‚ÇÄ a)
  | in‚ÇÄ‚ÇÇ ‚¶Éa b c‚¶Ñ : (a, b, c) ‚àà t ‚Üí Rel (in‚ÇÄ a) (in‚ÇÇ c)
  | in‚ÇÇ‚ÇÄ ‚¶Éa b c‚¶Ñ : (a, b, c) ‚àà t ‚Üí Rel (in‚ÇÇ c) (in‚ÇÄ a)
  | in‚ÇÅ‚ÇÇ ‚¶Éa b c‚¶Ñ : (a, b, c) ‚àà t ‚Üí Rel (in‚ÇÅ b) (in‚ÇÇ c)
  | in‚ÇÇ‚ÇÅ ‚¶Éa b c‚¶Ñ : (a, b, c) ‚àà t ‚Üí Rel (in‚ÇÇ c) (in‚ÇÅ b)

open Rel

theorem rel_irrefl : ‚àÄ x, ¬¨Rel t x x :=
  fun.

theorem rel_symm : Symmetric (Rel t) := fun x y h => by cases h <;> constructor <;> assumption

/-- The tripartite-from-triangles graph. Two vertices are related iff there exists a triangle index
containing them both. -/
def graph (t : Finset (Œ± √ó Œ≤ √ó Œ≥)) : SimpleGraph (Sum Œ± (Sum Œ≤ Œ≥)) :=
  ‚ü®Rel t, rel_symm, rel_irrefl‚ü©

namespace Graph

@[simp]
theorem not_in‚ÇÄ‚ÇÄ : ¬¨(graph t).Adj (in‚ÇÄ a) (in‚ÇÄ a') :=
  fun.

@[simp]
theorem not_in‚ÇÅ‚ÇÅ : ¬¨(graph t).Adj (in‚ÇÅ b) (in‚ÇÅ b') :=
  fun.

@[simp]
theorem not_in‚ÇÇ‚ÇÇ : ¬¨(graph t).Adj (in‚ÇÇ c) (in‚ÇÇ c') :=
  fun.

@[simp]
theorem in‚ÇÄ‚ÇÅ_iff : (graph t).Adj (in‚ÇÄ a) (in‚ÇÅ b) ‚Üî ‚àÉ c, (a, b, c) ‚àà t :=
  ‚ü®by rintro ‚ü®‚ü©; exact ‚ü®_, ‚Äπ_‚Ä∫‚ü©, fun ‚ü®_, h‚ü© => in‚ÇÄ‚ÇÅ h‚ü©

@[simp]
theorem in‚ÇÅ‚ÇÄ_iff : (graph t).Adj (in‚ÇÅ b) (in‚ÇÄ a) ‚Üî ‚àÉ c, (a, b, c) ‚àà t :=
  ‚ü®by rintro ‚ü®‚ü©; exact ‚ü®_, ‚Äπ_‚Ä∫‚ü©, fun ‚ü®_, h‚ü© => in‚ÇÅ‚ÇÄ h‚ü©

@[simp]
theorem in‚ÇÄ‚ÇÇ_iff : (graph t).Adj (in‚ÇÄ a) (in‚ÇÇ c) ‚Üî ‚àÉ b, (a, b, c) ‚àà t :=
  ‚ü®by rintro ‚ü®‚ü©; exact ‚ü®_, ‚Äπ_‚Ä∫‚ü©, fun ‚ü®_, h‚ü© => in‚ÇÄ‚ÇÇ h‚ü©

@[simp]
theorem in‚ÇÇ‚ÇÄ_iff : (graph t).Adj (in‚ÇÇ c) (in‚ÇÄ a) ‚Üî ‚àÉ b, (a, b, c) ‚àà t :=
  ‚ü®by rintro ‚ü®‚ü©; exact ‚ü®_, ‚Äπ_‚Ä∫‚ü©, fun ‚ü®_, h‚ü© => in‚ÇÇ‚ÇÄ h‚ü©

@[simp]
theorem in‚ÇÅ‚ÇÇ_iff : (graph t).Adj (in‚ÇÅ b) (in‚ÇÇ c) ‚Üî ‚àÉ a, (a, b, c) ‚àà t :=
  ‚ü®by rintro ‚ü®‚ü©; exact ‚ü®_, ‚Äπ_‚Ä∫‚ü©, fun ‚ü®_, h‚ü© => in‚ÇÅ‚ÇÇ h‚ü©

@[simp]
theorem in‚ÇÇ‚ÇÅ_iff : (graph t).Adj (in‚ÇÇ c) (in‚ÇÅ b) ‚Üî ‚àÉ a, (a, b, c) ‚àà t :=
  ‚ü®by rintro ‚ü®‚ü©; exact ‚ü®_, ‚Äπ_‚Ä∫‚ü©, fun ‚ü®_, h‚ü© => in‚ÇÇ‚ÇÅ h‚ü©

theorem in‚ÇÄ‚ÇÅ_iff' :
    (graph t).Adj (in‚ÇÄ a) (in‚ÇÅ b) ‚Üî ‚àÉ (x : Œ± √ó Œ≤ √ó Œ≥) (hx : x ‚àà t), x.1 = a ‚àß x.2.1 = b :=
  ‚ü®by rintro ‚ü®‚ü©; exact ‚ü®_, ‚Äπ_‚Ä∫, rfl, rfl‚ü©, by rintro ‚ü®‚ü®a, b, c‚ü©, h, rfl, rfl‚ü©; constructor;
    assumption‚ü©

theorem in‚ÇÅ‚ÇÄ_iff' :
    (graph t).Adj (in‚ÇÅ b) (in‚ÇÄ a) ‚Üî ‚àÉ (x : Œ± √ó Œ≤ √ó Œ≥) (hx : x ‚àà t), x.2.1 = b ‚àß x.1 = a :=
  ‚ü®by rintro ‚ü®‚ü©; exact ‚ü®_, ‚Äπ_‚Ä∫, rfl, rfl‚ü©, by rintro ‚ü®‚ü®a, b, c‚ü©, h, rfl, rfl‚ü©; constructor;
    assumption‚ü©

theorem in‚ÇÄ‚ÇÇ_iff' :
    (graph t).Adj (in‚ÇÄ a) (in‚ÇÇ c) ‚Üî ‚àÉ (x : Œ± √ó Œ≤ √ó Œ≥) (hx : x ‚àà t), x.1 = a ‚àß x.2.2 = c :=
  ‚ü®by rintro ‚ü®‚ü©; exact ‚ü®_, ‚Äπ_‚Ä∫, rfl, rfl‚ü©, by rintro ‚ü®‚ü®a, b, c‚ü©, h, rfl, rfl‚ü©; constructor;
    assumption‚ü©

theorem in‚ÇÇ‚ÇÄ_iff' :
    (graph t).Adj (in‚ÇÇ c) (in‚ÇÄ a) ‚Üî ‚àÉ (x : Œ± √ó Œ≤ √ó Œ≥) (hx : x ‚àà t), x.2.2 = c ‚àß x.1 = a :=
  ‚ü®by rintro ‚ü®‚ü©; exact ‚ü®_, ‚Äπ_‚Ä∫, rfl, rfl‚ü©, by rintro ‚ü®‚ü®a, b, c‚ü©, h, rfl, rfl‚ü©; constructor;
    assumption‚ü©

theorem in‚ÇÅ‚ÇÇ_iff' :
    (graph t).Adj (in‚ÇÅ b) (in‚ÇÇ c) ‚Üî ‚àÉ (x : Œ± √ó Œ≤ √ó Œ≥) (hx : x ‚àà t), x.2.1 = b ‚àß x.2.2 = c :=
  ‚ü®by rintro ‚ü®‚ü©; exact ‚ü®_, ‚Äπ_‚Ä∫, rfl, rfl‚ü©, by rintro ‚ü®‚ü®a, b, c‚ü©, h, rfl, rfl‚ü©; constructor;
    assumption‚ü©

theorem in‚ÇÇ‚ÇÅ_iff' :
    (graph t).Adj (in‚ÇÇ c) (in‚ÇÅ b) ‚Üî ‚àÉ (x : Œ± √ó Œ≤ √ó Œ≥) (hx : x ‚àà t), x.2.2 = c ‚àß x.2.1 = b :=
  ‚ü®by rintro ‚ü®‚ü©; exact ‚ü®_, ‚Äπ_‚Ä∫, rfl, rfl‚ü©, by rintro ‚ü®‚ü®a, b, c‚ü©, h, rfl, rfl‚ü©; constructor;
    assumption‚ü©

end Graph

open Graph

/-- Predicate on the triangle indices for the explicit triangles to be edge-disjoint. -/
class ExplicitDisjoint (t : Finset (Œ± √ó Œ≤ √ó Œ≥)) : Prop where
  inj‚ÇÄ : ‚àÄ ‚¶Éa b c a'‚¶Ñ, (a, b, c) ‚àà t ‚Üí (a', b, c) ‚àà t ‚Üí a = a'
  inj‚ÇÅ : ‚àÄ ‚¶Éa b c b'‚¶Ñ, (a, b, c) ‚àà t ‚Üí (a, b', c) ‚àà t ‚Üí b = b'
  inj‚ÇÇ : ‚àÄ ‚¶Éa b c c'‚¶Ñ, (a, b, c) ‚àà t ‚Üí (a, b, c') ‚àà t ‚Üí c = c'

/-- Predicate on the triangle indices for there to be no accidental triangle.

Note that we cheat a bit, since the exact translation of this informal description would have
`(a', b', c') ‚àà s` as a conclusion rather than `a = a' ‚à® b = b' ‚à® c = c'`. Those conditions are
equivalent when the explicit triangles are edge-disjoint (which is the case we care about). -/
class NoAccidental (t : Finset (Œ± √ó Œ≤ √ó Œ≥)) : Prop where
  wow :
    ‚àÄ ‚¶Éa a' b b' c c'‚¶Ñ, (a', b, c) ‚àà t ‚Üí (a, b', c) ‚àà t ‚Üí (a, b, c') ‚àà t ‚Üí a = a' ‚à® b = b' ‚à® c = c'

section DecidableEq

variable [DecidableEq Œ±] [DecidableEq Œ≤] [DecidableEq Œ≥]

instance : DecidableRel (graph t).Adj
  | in‚ÇÄ a, in‚ÇÄ a' => Decidable.isFalse not_in‚ÇÄ‚ÇÄ
  | in‚ÇÄ a, in‚ÇÅ b' => decidable_of_iff' _ in‚ÇÄ‚ÇÅ_iff'
  | in‚ÇÄ a, in‚ÇÇ c' => decidable_of_iff' _ in‚ÇÄ‚ÇÇ_iff'
  | in‚ÇÅ b, in‚ÇÄ a' => decidable_of_iff' _ in‚ÇÅ‚ÇÄ_iff'
  | in‚ÇÅ b, in‚ÇÅ b' => Decidable.isFalse not_in‚ÇÅ‚ÇÅ
  | in‚ÇÅ b, in‚ÇÇ b' => decidable_of_iff' _ in‚ÇÅ‚ÇÇ_iff'
  | in‚ÇÇ c, in‚ÇÄ a' => decidable_of_iff' _ in‚ÇÇ‚ÇÄ_iff'
  | in‚ÇÇ c, in‚ÇÅ b' => decidable_of_iff' _ in‚ÇÇ‚ÇÅ_iff'
  | in‚ÇÇ c, in‚ÇÇ b' => Decidable.isFalse not_in‚ÇÇ‚ÇÇ

/-- This lemma reorders the elements of a triangle in the tripartite graph. It turns a triangle
`{x, y, z}` into a triangle `{a, b, c}` where `a : Œ± `, `b : Œ≤`, `c : Œ≥`. -/
theorem graph_triple ‚¶Éx y z‚¶Ñ :
    (graph t).Adj x y ‚Üí
      (graph t).Adj x z ‚Üí
        (graph t).Adj y z ‚Üí
          ‚àÉ a b c,
            ({in‚ÇÄ a, in‚ÇÅ b, in‚ÇÇ c} : Finset (Sum Œ± (Sum Œ≤ Œ≥))) = {x, y, z} ‚àß
              (graph t).Adj (in‚ÇÄ a) (in‚ÇÅ b) ‚àß
                (graph t).Adj (in‚ÇÄ a) (in‚ÇÇ c) ‚àß (graph t).Adj (in‚ÇÅ b) (in‚ÇÇ c) :=
  by
  rintro (_ | _ | _) (_ | _ | _) (_ | _ | _) <;>
        refine'
          ‚ü®_, _, _, by ext <;> simp only [Finset.mem_insert, Finset.mem_singleton] <;> try tauto, _,
            _, _‚ü© <;>
      constructor <;>
    assumption

/-- The map that turns a triangle index into an explicit triangle. -/
@[simps]
def toTriangle : Œ± √ó Œ≤ √ó Œ≥ ‚Ü™ Finset (Sum Œ± (Sum Œ≤ Œ≥))
    where
  toFun x := {in‚ÇÄ x.1, in‚ÇÅ x.2.1, in‚ÇÇ x.2.2}
  inj' := fun ‚ü®a, b, c‚ü© ‚ü®a', b', c'‚ü© => by
    simpa only [Finset.Subset.antisymm_iff, Finset.subset_iff, mem_insert, mem_singleton,
      forall_eq_or_imp, forall_eq, Prod.mk.inj_iff, or_false_iff, false_or_iff, in‚ÇÄ, in‚ÇÅ, in‚ÇÇ,
      Sum.inl.inj_eq, Sum.inr.inj_eq] using And.left

theorem toTriangle_is_3_clique (hx : x ‚àà t) : (graph t).IsNClique 3 (toTriangle x) :=
  by
  rcases x with ‚ü®a, b, c‚ü©
  simp only [to_triangle_apply, is_3_clique_triple_iff, in‚ÇÄ‚ÇÅ_iff, in‚ÇÄ‚ÇÇ_iff, in‚ÇÅ‚ÇÇ_iff]
  exact ‚ü®‚ü®_, hx‚ü©, ‚ü®_, hx‚ü©, _, hx‚ü©

theorem exists_mem_toTriangle {x y : Sum Œ± (Sum Œ≤ Œ≥)} (hxy : (graph t).Adj x y) :
    ‚àÉ z ‚àà t, x ‚àà toTriangle z ‚àß y ‚àà toTriangle z := by cases hxy <;> exact ‚ü®_, ‚Äπ_‚Ä∫, by simp‚ü©

theorem is_3_clique_iff [NoAccidental t] {s : Finset (Sum Œ± (Sum Œ≤ Œ≥))} :
    (graph t).IsNClique 3 s ‚Üî ‚àÉ x, x ‚àà t ‚àß toTriangle x = s :=
  by
  refine' ‚ü®fun h => _, _‚ü©
  ¬∑ rw [is_3_clique_iff] at h 
    obtain ‚ü®x, y, z, hxy, hxz, hyz, rfl‚ü© := h
    obtain ‚ü®a, b, c, habc, hab, hac, hbc‚ü© := graph_triple hxy hxz hyz
    refine' ‚ü®(a, b, c), _, habc‚ü©
    obtain ‚ü®c', hc'‚ü© := in‚ÇÄ‚ÇÅ_iff.1 hab
    obtain ‚ü®b', hb'‚ü© := in‚ÇÄ‚ÇÇ_iff.1 hac
    obtain ‚ü®a', ha'‚ü© := in‚ÇÅ‚ÇÇ_iff.1 hbc
    obtain rfl | rfl | rfl := no_accidental.wow ha' hb' hc' <;> assumption
  ¬∑ rintro ‚ü®x, hx, rfl‚ü©
    exact to_triangle_is_3_clique hx

theorem toTriangle_surjOn [NoAccidental t] :
    (t : Set (Œ± √ó Œ≤ √ó Œ≥)).SurjOn toTriangle ((graph t).cliqueSet 3) := fun s => is_3_clique_iff.1

variable (t)

theorem map_toTriangle_disjoint [ExplicitDisjoint t] :
    (t.map toTriangle : Set (Finset (Sum Œ± (Sum Œ≤ Œ≥)))).Pairwise fun x y =>
      (x ‚à© y : Set (Sum Œ± (Sum Œ≤ Œ≥))).Subsingleton :=
  by
  intro
  simp only [Finset.coe_map, Set.mem_image, Finset.mem_coe, Prod.exists, Ne.def,
    forall_exists_index, and_imp]
  rintro a b c habc rfl e x y z hxyz rfl h'
  have := ne_of_apply_ne _ h'
  simp only [Ne.def, Prod.mk.inj_iff, not_and] at this 
  simp only [to_triangle_apply, in‚ÇÄ, in‚ÇÅ, in‚ÇÇ, Set.mem_inter_iff, mem_insert, mem_singleton,
    mem_coe, and_imp, Sum.forall, or_false_iff, forall_eq, false_or_iff, eq_self_iff_true,
    imp_true_iff, true_and_iff, and_true_iff, Set.Subsingleton]
  suffices ¬¨(a = x ‚àß b = y) ‚àß ¬¨(a = x ‚àß c = z) ‚àß ¬¨(b = y ‚àß c = z) by tauto
  refine' ‚ü®_, _, _‚ü©
  ¬∑ rintro ‚ü®rfl, rfl‚ü©
    exact this rfl rfl (explicit_disjoint.inj‚ÇÇ habc hxyz)
  ¬∑ rintro ‚ü®rfl, rfl‚ü©
    exact this rfl (explicit_disjoint.inj‚ÇÅ habc hxyz) rfl
  ¬∑ rintro ‚ü®rfl, rfl‚ü©
    exact this (explicit_disjoint.inj‚ÇÄ habc hxyz) rfl rfl

theorem cliqueSet_eq_image [NoAccidental t] : (graph t).cliqueSet 3 = toTriangle '' t := by
  ext <;> exact is_3_clique_iff

section Fintype

variable [Fintype Œ±] [Fintype Œ≤] [Fintype Œ≥]

theorem cliqueFinset_eq_image [NoAccidental t] : (graph t).cliqueFinset 3 = t.image toTriangle :=
  coe_injective <| by push_cast; exact clique_set_eq_image _

theorem cliqueFinset_eq_map [NoAccidental t] : (graph t).cliqueFinset 3 = t.map toTriangle := by
  simp [clique_finset_eq_image, map_eq_image]

@[simp]
theorem card_triangles [NoAccidental t] : ((graph t).cliqueFinset 3).card = t.card := by
  rw [clique_finset_eq_map, card_map]

theorem farFromTriangleFree [ExplicitDisjoint t] {Œµ : ùïú}
    (ht : Œµ * ((Fintype.card Œ± + Fintype.card Œ≤ + Fintype.card Œ≥) ^ 2 : ‚Ñï) ‚â§ t.card) :
    (graph t).FarFromTriangleFree Œµ :=
  farFromTriangleFree_of_disjoint_triangles (t.map toTriangle)
      (map_subset_iff_subset_preimage.2 fun x hx => by simpa using to_triangle_is_3_clique hx)
      (map_toTriangle_disjoint t) <|
    by simpa [add_assoc] using ht

end Fintype

end DecidableEq

variable (t)

theorem locallyLinear [ExplicitDisjoint t] [NoAccidental t] : (graph t).LocallyLinear := by
  classical
  refine' ‚ü®_, fun x y hxy => _‚ü©
  ¬∑ unfold edge_disjoint_triangles
    convert map_to_triangle_disjoint t
    rw [clique_set_eq_image, coe_map]
  ¬∑ obtain ‚ü®z, hz, hxy‚ü© := exists_mem_to_triangle hxy
    exact ‚ü®_, to_triangle_is_3_clique hz, hxy‚ü©

end TripartiteFromTriangles

end SimpleGraph

