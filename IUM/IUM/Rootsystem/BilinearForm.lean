import Data.Set.Function
import LinearAlgebra.BilinearForm
import Rootsystem.Dual

#align_import rootsystem.bilinear_form

noncomputable section

open scoped TensorProduct BigOperators Classical

open Set Function

namespace IsRootSystem

-- Need ordering of scalars to have concept of positive definiteness which we will use in proofs
-- below
variable {k V : Type _} [LinearOrderedField k] [CharZero k] [AddCommGroup V] [Module k V]

variable {Φ : Set V} (h : IsRootSystem k Φ)

local postfix:100 "ᘁ" => h.coroot

local notation "ട" => h.symmetryOfRoot

/-- The linear map `V → V⋆` induced by a root system. -/
@[simps]
def toDual : V →ₗ[k] Module.Dual k V
    where
  toFun x := ∑ᶠ α, (αᘁ) x • αᘁ
  map_add' x y := by
    ext
    simp only [LinearMap.map_add, map_add, LinearMap.add_apply, add_smul]
    rw [finsum_add_distrib]
    simp only [LinearMap.add_apply]
    · haveI : Finite Φ := finite_coe_iff.mpr h.finite
      apply Set.toFinite
    · haveI : Finite Φ := finite_coe_iff.mpr h.finite
      apply Set.toFinite
  map_smul' := by
    intro c x
    ext
    simp only [LinearMap.map_smulₛₗ, RingHom.id_apply, Algebra.id.smul_eq_mul, LinearMap.smul_apply,
      ← smul_smul]
    rw [← smul_finsum]
    simp only [LinearMap.smul_apply, Algebra.id.smul_eq_mul]

theorem toDual_apply_apply (x y : V) : h.toDual x y = ∑ᶠ α, (αᘁ) x • (αᘁ) y :=
  by
  haveI h2 : Finite Φ := finite_coe_iff.mpr h.finite
  have h3 : (support fun α : ↥Φ => (αᘁ) x • αᘁ).Finite := by apply Set.toFinite
  change (∑ᶠ α : Φ, (αᘁ) x • αᘁ) y = _
  letI : Fintype Φ := Fintype.ofFinite ↥Φ
  rw [finsum_eq_finset_sum_of_support_subset _ (_ : _ ⊆ ↑(Finset.univ : Finset Φ))]
  rw [finsum_eq_finset_sum_of_support_subset _ (_ : _ ⊆ ↑(Finset.univ : Finset Φ))]
  · simp only [LinearMap.coeFn_sum, Fintype.sum_apply, LinearMap.smul_apply]
  · simp only [Finset.coe_univ, subset_univ]
  · simp only [Finset.coe_univ, support_subset_iff, mem_univ, imp_true_iff]

/-- The bilinear map on `V` induced by a root system. -/
def toBilinearMap : V →ₗ[k] V →ₗ[k] k
    where
  toFun x := h.toDual x
  map_add' x y := by ext; simp only [map_add]
  map_smul' c x := by ext; simp only [LinearMap.map_smulₛₗ]

/-- The bilinear form on `V` induced by a root system. -/
def toBilinForm : BilinForm k V :=
  h.toBilinearMap.toBilin

-- Don't have any zeros or -1s in the matrix only over the real numbers
theorem toBilinForm_anisotropic : h.toBilinForm.toQuadraticForm.Anisotropic :=
  by
  apply QuadraticForm.PosDef.anisotropic
  intro v hv
  simp only [to_bilin_form, to_bilinear_map, BilinForm.toQuadraticForm_apply, LinearMap.mk_coe]
  change 0 < h.to_dual v v
  rw [to_dual_apply_apply]
  replace hv : ∃ β : Φ, (βᘁ) v ≠ 0
  · -- should follow from fact that the coroots span
    contrapose! hv
    exact h.coroot_eq_zero_only_if_v_eq_zero v hv
  obtain ⟨β, hβ⟩ := hv
  replace hβ : 0 < (βᘁ) v * (βᘁ) v
  · exact mul_self_pos.mpr hβ
  haveI : Finite Φ := finite_coe_iff.mpr h.finite
  have h2 : (support fun i : ↥Φ => (h.coroot i) v • (h.coroot i) v).Finite := by apply Set.toFinite
  replace hβ : 0 < ∑ᶠ α : Φ, (αᘁ) v * (αᘁ) v
  · refine' lt_of_lt_of_le hβ _
    rw [finsum_eq_sum (fun i : ↥Φ => (h.coroot i) v * (h.coroot i) v) h2]
    · refine'
        @Finset.single_le_sum Φ k _ (fun i : ↥Φ => (h.coroot i) v * (h.coroot i) v) h2.to_finset _ _
          _
      · intro i hi
        simp only
        exact mul_self_nonneg _
      · rw [Set.Finite.mem_toFinset, mem_support]
        simpa only [Algebra.id.smul_eq_mul, Ne.def, mul_eq_zero, or_self_iff, mul_self_pos] using hβ
  exact hβ

/-- This corresponds to the bilinear form on V induced by the root system being nonsingular -/
theorem ker_to_dual_eq_bot : h.toBilinForm.Nondegenerate :=
  BilinForm.nondegenerate_of_anisotropic h.toBilinForm_anisotropic

--set_option pp.implicit true
--set_option pp.notation false
-- Bilinear form is dot product, Weyl group is subgroup generated by reflections in the roots,
-- Reflection preserve lengths and angles
-- Therefore bilinear form is preserved
-- Built into some people's definitions, but for us it's a theorem
-- In a Euclidean space we have concept of orthogonality and therefore of reflections
-- Reflections automatically have this property, but we started with weaker assumptions
-- Estimate medium effort.
@[simp]
theorem toBilinForm_symmetry_eq (u : V ≃ₗ[k] V) (hu : u ∈ h.symmetries) (x y : V) :
    h.toBilinForm (u • x) (u • y) = h.toBilinForm x y :=
  by
  have hu' : u.symm ∈ h.symmetries := inv_mem_iff.mpr hu
  have hα : ∀ α : Φ, u.symm α ∈ Φ :=
    by
    rw [mem_symmetries_iff] at hu' 
    intro α
    apply Eq.subset hu'
    exact ⟨α, α.2, rfl⟩
  let u' := u.dual_map
  have h' : ∀ α : Φ, u.dual_map (h.coroot α) = h.coroot ⟨u.symm α, hα α⟩ :=
    by
    intro α
    rw [coroot_apply_of_mem_symmetries h u.symm hu' α (hα α), LinearEquiv.symm_symm]
  have hbtd : ∀ a b, h.to_dual a b = h.to_bilin_form a b; intros; rfl
  rw [← hbtd]
  rw [to_dual_apply_apply]
  dsimp only [SMul.smul]
  simp_rw [← LinearEquiv.dualMap_apply, h']
  have hbij : Set.BijOn u.symm Φ Φ :=
    by
    rw [← LinearEquiv.coe_toEquiv]
    suffices Set.BijOn u.symm Φ (u.symm '' Φ) by rw [(mem_symmetries_iff h u.symm).mp hu'] at this ;
      exact this
    apply Equiv.bijOn_image u.symm.to_equiv
  let u_set := Set.BijOn.equiv u.symm hbij
  have hu'' : ∀ α : Φ, u.symm α = u_set α := fun α => rfl
  simp_rw [hu'']
  simp only [Subtype.coe_eta]
  rw [@finsum_comp_equiv Φ Φ k _ u_set fun i => (h.coroot i) x * (h.coroot i) y]
  change ∑ᶠ i : Φ, (h.coroot i) x • (h.coroot i) y = _
  rw [← to_dual_apply_apply]
  rfl

theorem toBilinForm_weyl_eq (g : V ≃ₗ[k] V) (hg : g ∈ h.weylGroup) (x y : V) :
    h.toBilinForm (g • x) (g • y) = h.toBilinForm x y :=
  by
  have hg' : g ∈ h.symmetries := by
    apply weyl_group_le_symmetries
    exact hg
  apply to_bilin_form_symmetry_eq h g hg'

-- Estimate high effort.
theorem toBilinForm_orthogonal_eq_ker (α : Φ) : h.toBilinForm.orthogonal (k ∙ (α : V)) = αᘁ.ker :=
  by
  have hα' : h.to_bilin_form α α ≠ 0 :=
    by
    have h' := h.to_bilin_form_anisotropic
    contrapose! h'
    rw [QuadraticForm.not_anisotropic_iff_exists]
    exact ⟨α, h.root_ne_zero α, h'⟩
  suffices ∀ v : V, (h.coroot α) v = 2 * h.to_bilin_form α v / h.to_bilin_form α α
    by
    have hb : ∀ v : V, h.to_bilin_form α v = 0 ↔ (αᘁ) v = 0 :=
      by
      intro v
      refine' ⟨fun hbα => _, fun hbα => _⟩
      · rw [this, hbα, MulZeroClass.mul_zero]
        exact zero_div _
      · specialize this v
        rw [hbα, eq_comm, div_eq_zero_iff] at this 
        cases this
        · simpa only [mul_eq_zero, bit0_eq_zero, one_ne_zero, false_or_iff] using this
        · contradiction
    ext v
    rw [BilinForm.mem_orthogonal_iff]
    rw [LinearMap.mem_ker]
    simp_rw [BilinForm.isOrtho_def]
    refine' ⟨fun h => _, fun h => _⟩
    · specialize h (α : V)
      rw [hb] at h 
      rw [h]
      rw [Submodule.mem_span]
      simp only [singleton_subset_iff, SetLike.mem_coe, imp_self, forall_const]
    · intro n hn
      rw [Submodule.mem_span_singleton] at hn 
      rcases hn with ⟨z, rfl⟩
      simp only [BilinForm.smul_left, mul_eq_zero]
      refine' Or.intro_right _ _
      rw [hb]
      exact h
  intro v
  let u := h.symmetry_of_root α
  have hu : u ∈ h.symmetries := by simp only [mem_symmetries_iff, symmetry_of_root_image_eq]
  have hu' : h.to_bilin_form α v = (h.coroot α) v * h.to_bilin_form α α - h.to_bilin_form α v := by
    conv =>
      lhs
      rw [← h.to_bilin_form_symmetry_eq u hu α v]
      dsimp [(· • ·)]
      rw [h.symmetry_of_root_apply_self_neg α, h.symmetry_of_root_apply, BilinForm.sub_right,
        BilinForm.neg_left, BilinForm.smul_right, BilinForm.neg_left]
      simp only [mul_neg, neg_sub_neg, sub_sub_cancel]
  rw [eq_sub_iff_add_eq, ← two_mul] at hu' 
  rw [hu', mul_div_cancel _ hα']

end IsRootSystem

